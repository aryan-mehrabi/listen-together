create type "public"."playlist_types" as enum ('vote', 'queue');

create table "public"."playlists" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null default ''::text,     
    "channel_id" bigint not null,
    "type" playlist_types not null default 'queue'::playlist_types
);


create table "public"."tracks" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "track_id" text not null default 'nOubjLM9Cbc'::text,
    "metadata" jsonb,
    "playlist_id" bigint not null,
    "user_id" uuid default gen_random_uuid(),  
    "position" bigint not null default '0'::bigint,
    "is_played" boolean not null default false 
);


create table "public"."votes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default gen_random_uuid(),
    "track_id" bigint not null
);



alter table "public"."channels" add column "duration" real;

alter table "public"."channels" add column "playlist_id" bigint;

alter table "public"."channels" add column "start_at" timestamp with time zone;

alter table "public"."channels" add column "track_id" bigint;

alter table "public"."channels" alter column "is_playing" set default false;

alter table "public"."channels" alter column "position" set default '0'::real;

alter table "public"."channels" alter column "position" drop not null;

CREATE UNIQUE INDEX playlists_pkey ON public.playlists USING btree (id);

CREATE UNIQUE INDEX tracks_pkey ON public.tracks USING btree (id);

CREATE UNIQUE INDEX unique_channel_id_for_queue ON public.playlists USING btree (channel_id) WHERE (type = 'queue'::playlist_types);

CREATE UNIQUE INDEX unique_user_track ON public.votes USING btree (user_id, track_id);        

CREATE UNIQUE INDEX votes_pkey ON public.votes 
USING btree (id);

alter table "public"."playlists" add constraint "playlists_pkey" PRIMARY KEY using index "playlists_pkey";

alter table "public"."tracks" add constraint "tracks_pkey" PRIMARY KEY using index "tracks_pkey";

alter table "public"."votes" add constraint "votes_pkey" PRIMARY KEY using index "votes_pkey";
alter table "public"."channels" add constraint 
"channels_playlist_id_fkey" FOREIGN KEY (playlist_id) REFERENCES playlists(id) not valid;     

alter table "public"."channels" validate constraint "channels_playlist_id_fkey";

alter table "public"."channels" add constraint 
"channels_track_id_fkey" FOREIGN KEY (track_id) REFERENCES tracks(id) ON DELETE SET NULL not valid;

alter table "public"."channels" validate constraint "channels_track_id_fkey";

alter table "public"."playlists" add constraint "playlists_channel_id_fkey" FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE CASCADE not valid;

alter table "public"."playlists" validate constraint "playlists_channel_id_fkey";

alter table "public"."tracks" add constraint "tracks_playlist_id_fkey" FOREIGN KEY (playlist_id) REFERENCES playlists(id) ON DELETE CASCADE not valid;

alter table "public"."tracks" validate constraint "tracks_playlist_id_fkey";

alter table "public"."tracks" add constraint "tracks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."tracks" validate constraint "tracks_user_id_fkey";

alter table "public"."votes" add constraint "unique_user_track" UNIQUE using index "unique_user_track";

alter table "public"."votes" add constraint "votes_track_id_fkey" FOREIGN KEY (track_id) REFERENCES tracks(id) ON DELETE CASCADE not valid;  

alter table "public"."votes" validate constraint "votes_track_id_fkey";

alter table "public"."votes" add constraint "votes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."votes" validate constraint "votes_user_id_fkey";

INSERT INTO playlists (channel_id, type, name)
SELECT c.id AS channel_id, 'queue' AS type, 'queue' AS name
FROM channels c;

INSERT INTO tracks (track_id, playlist_id, position, user_id)
SELECT c.track AS track_id, p.id AS playlist_id, 0, null
FROM playlists p
JOIN channels c ON p.channel_id = c.id;

UPDATE channels c
SET track_id = t.id,
    playlist_id = p.id
FROM playlists p
JOIN tracks t ON p.id = t.playlist_id
WHERE c.id = p.channel_id;

alter table "public"."channels" drop column "track";


set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.delete_track_from_queue(_id bigint, _playlist_id bigint)    
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  _deleted_position INT;
BEGIN
  -- Step 1: Find the position of the track to 
be deleted
  SELECT position INTO _deleted_position       
  FROM tracks
  WHERE id = _id;

  -- Step 2: Delete the track
  DELETE FROM tracks
  WHERE id = _id;

  -- Step 3: Shift positions of remaining tracks
  UPDATE tracks
  SET position = position - 1
  WHERE playlist_id = _playlist_id
    AND position > _deleted_position;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.move_track(_id integer, _new_position integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    current_position INT;
    _playlist_id INT;
BEGIN
    -- Get the current position and playlist_id of the track
    SELECT t.position, t.playlist_id
    INTO current_position, _playlist_id        
    FROM tracks t
    WHERE t.id = _id;

    -- If the track is not found, raise an exception
    IF current_position IS NULL THEN
        RAISE EXCEPTION 'Track with ID % not found in the queue', _id;
    END IF;

    -- If the new position is the same as the current position, do nothing
    IF current_position = _new_position THEN   
        RETURN;
    END IF;

    -- If the track is moving up (to a lower position number)
    IF current_position > _new_position THEN   
        UPDATE tracks
        SET position = position + 1
        WHERE position >= _new_position        
          AND position < current_position      
          AND playlist_id = _playlist_id;      

    -- If the track is moving down (to a higher position number)
    ELSE
        UPDATE tracks
        SET position = position - 1
        WHERE position <= _new_position        
          AND position > current_position      
          AND playlist_id = _playlist_id;      
    END IF;

    -- Update the track's position
    UPDATE tracks
    SET position = _new_position
    WHERE id = _id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.play_next_track(_id bigint, _channel_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE tracks
  SET is_played = true
  WHERE id = _id;

  UPDATE channels
  set track_id = _id, position = 0, is_playing 
= true
  where id = _channel_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.play_track(_track_id text, _metadata json, _playlist_id bigint, _position bigint, _channel_id bigint)      
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$DECLARE
  new_track_id BIGINT; -- Variable to store the ID of the newly inserted track
BEGIN
  IF _position < 0 THEN
    RAISE EXCEPTION 'Position must be greater than or equal to 0';
  END IF;


  -- Shift all tracks with positions greater than or equal to (_position + 1)
  UPDATE tracks
  SET position = position + 1
  WHERE playlist_id = _playlist_id
    AND position >= _position + 1;

  -- Insert the new track at (_position + 1) and capture its ID
  INSERT INTO tracks (track_id, metadata, playlist_id, user_id, position, is_played)
  VALUES (
    _track_id,
    _metadata,
    _playlist_id,
    auth.uid(),
    _position + 1,
    true
  )
  RETURNING id INTO new_track_id;

  -- Update the corresponding channel's track_id with the new track_id
  UPDATE channels
  SET track_id = new_track_id, playlist_id = _playlist_id
  WHERE id = _channel_id;  -- Adjust the condition as per your logic
END;$function$
;

CREATE OR REPLACE FUNCTION public.queue_track(_track_id text, _metadata json, _playlist_id bigint)
 RETURNS SETOF tracks
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Insert the track and return the inserted row
  RETURN QUERY
  WITH max_position AS (
    SELECT COALESCE(MAX(position), 0) AS current_max
    FROM tracks
    WHERE playlist_id = _playlist_id
  )
  INSERT INTO tracks (track_id, metadata, playlist_id, user_id, position)
  VALUES (
    _track_id,
    _metadata,
    _playlist_id,
    auth.uid(),
    (SELECT current_max + 1 FROM max_position) 
  )
  RETURNING *;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_start_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if either "position" or "is_playing" was updated
    IF NEW.position IS DISTINCT FROM OLD.position OR
       NEW.is_playing IS DISTINCT FROM OLD.is_playing THEN

        NEW.start_at = now();

        -- You can add additional logic here if needed
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_channel(name text, url text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare
  new_channel channels;
  new_channel_invite channel_invites;
  new_playlist playlists;
  new_track tracks;
  result json;
begin
  insert into channels (name)
  values (name)
  returning * into new_channel;

  insert into members (channel_id, user_id, role)
  values (new_channel.id, auth.uid(), 'creator');

  insert into channel_invites (channel_id, url)  values (new_channel.id, url)
  returning * into new_channel_invite;

  insert into playlists (name, type, channel_id)
  values ('queue', 'queue', new_channel.id)    
  returning * into new_playlist;

  insert into tracks (playlist_id, user_id)    
  values (new_playlist.id, auth.uid())
  returning * into new_track;

  update channels
  set playlist_id = new_playlist.id,
  track_id = new_track.id
  where id = new_channel.id;

  select json_build_object('channels', new_channel, 'channel_invites', new_channel_invite) into result;

  return result;
end;$function$
;

grant delete on table "public"."playlists" to "anon";

grant insert on table "public"."playlists" to "anon";

grant references on table "public"."playlists" 
to "anon";

grant select on table "public"."playlists" to "anon";

grant trigger on table "public"."playlists" to 
"anon";

grant truncate on table "public"."playlists" to "anon";

grant update on table "public"."playlists" to "anon";

grant delete on table "public"."playlists" to "authenticated";

grant insert on table "public"."playlists" to "authenticated";

grant references on table "public"."playlists" 
to "authenticated";

grant select on table "public"."playlists" to "authenticated";

grant trigger on table "public"."playlists" to 
"authenticated";

grant truncate on table "public"."playlists" to "authenticated";

grant update on table "public"."playlists" to "authenticated";

grant delete on table "public"."playlists" to "service_role";

grant insert on table "public"."playlists" to "service_role";

grant references on table "public"."playlists" 
to "service_role";

grant select on table "public"."playlists" to "service_role";

grant trigger on table "public"."playlists" to 
"service_role";

grant truncate on table "public"."playlists" to "service_role";

grant update on table "public"."playlists" to "service_role";

grant delete on table "public"."tracks" to "anon";

grant insert on table "public"."tracks" to "anon";

grant references on table "public"."tracks" to 
"anon";

grant select on table "public"."tracks" to "anon";

grant trigger on table "public"."tracks" to "anon";

grant truncate on table "public"."tracks" to "anon";

grant update on table "public"."tracks" to "anon";

grant delete on table "public"."tracks" to "authenticated";

grant insert on table "public"."tracks" to "authenticated";

grant references on table "public"."tracks" to 
"authenticated";

grant select on table "public"."tracks" to "authenticated";

grant trigger on table "public"."tracks" to "authenticated";

grant truncate on table "public"."tracks" to "authenticated";

grant update on table "public"."tracks" to "authenticated";

grant delete on table "public"."tracks" to "service_role";

grant insert on table "public"."tracks" to "service_role";

grant references on table "public"."tracks" to 
"service_role";

grant select on table "public"."tracks" to "service_role";

grant trigger on table "public"."tracks" to "service_role";

grant truncate on table "public"."tracks" to "service_role";

grant update on table "public"."tracks" to "service_role";

grant delete on table "public"."votes" to "anon";

grant insert on table "public"."votes" to "anon";

grant references on table "public"."votes" to "anon";

grant select on table "public"."votes" to "anon";

grant trigger on table "public"."votes" to "anon";

grant truncate on table "public"."votes" to "anon";

grant update on table "public"."votes" to "anon";

grant delete on table "public"."votes" to "authenticated";

grant insert on table "public"."votes" to "authenticated";

grant references on table "public"."votes" to "authenticated";

grant select on table "public"."votes" to "authenticated";

grant trigger on table "public"."votes" to "authenticated";

grant truncate on table "public"."votes" to "authenticated";

grant update on table "public"."votes" to "authenticated";

grant delete on table "public"."votes" to "service_role";

grant insert on table "public"."votes" to "service_role";

grant references on table "public"."votes" to "service_role";

grant select on table "public"."votes" to "service_role";

grant trigger on table "public"."votes" to "service_role";

grant truncate on table "public"."votes" to "service_role";

grant update on table "public"."votes" to "service_role";

CREATE TRIGGER channel_update_trigger BEFORE UPDATE ON public.channels FOR EACH ROW EXECUTE FUNCTION update_start_at();

